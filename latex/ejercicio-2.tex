\textit{Diseñar e implementar un algoritmo exacto para CIDM.}

\subsection{Ejercicio A}

\textit{Explicar detalladamente el algoritmo implementado. Elaborar podas y estrategias que permitan mejorar los tiempos de resolucion.}

\medskip

\subsubsection{Estrategia}
El algoritmo implementado se basa en la Técnica Algorítmica de \textit{Backtracking}.

En primer lugar notese que un conjunto dominante trivial es el conjunto de todos los nodos del grafo. Si bien este conjunto en principio no es independiente (a menos que $X(G) = \emptyset$), es el conjunto dominante más grande posible (no hay ningún nodo que quede afuera, es decir: $V(G) \setminus D = \emptyset$).

Luego, la idea principal del algorítmo es empezar con este primer conjunto dominante e ir sacando nodos recursivamente mientras chequeamos dominancia e independencia. Cada vez que encontramos un conjunto dominante e independiente, nos fijamos su cardinal. Si el cardinal de este nuevo conjunto es menor que el mínimo hasta ese momento nos quedamos con el nuevo y lo guardamos como mínimo. En caso de que el cardinal sea mayor, seguimos quitando nodos para encontrar un conjunto más chico.

\subsubsection{Podas}

Antes de mostrar cuales son las podas que utilizamos en el algoritmo, veamos algunos Lemas.

    \begin{lemma}
        Sea C un conjunto dominante e independiente de un grafo G. Entonces, cualquier subconjunto de C (distinto de C) es no-dominante respecto a G.
    \end{lemma}
    \begin{proof}[Demostración]
        Veamos que vale por absurdo. Supongamos H un subconjunto de C tal que $H \subset C$ y H es dominante de G. Como H está estrictamente incluido en C, entonces $\exists\ v \in C$ tal que $v \notin H$.

        Ahora, como C es independiente, no hay nodos de C que sean adyacentes en G, en particular: $\forall\ w \in C,\ (v,w) \notin X(G)$.

        Entonces, $v \in V(G)$ pero $v \notin H$ y $\forall\ w \in H \subset C,\ (v,w) \notin X(G)$. Luego, H no es dominante, ya que el nodo v no está en H ni tiene algún vecino que esté en H. Absurdo.
    \end{proof}

    \begin{lemma}
        Sea C un conjunto no-dominante respecto a G. Entonces, cualquier subconjunto de C es no-dominate respecto a G.
    \end{lemma}
    \begin{proof}[Demostración]
        Trivial. Sea H un subconjunto de C ($H \subseteq C$).

        Como C es no-dominante, $\exists\ v \in V(G)$ tal que $v \notin C$ y $\forall\ w \in C,\ (v,w) \notin X(G)$.

        Pero como $H \subseteq C$, $v \notin H$ y $\forall\ w \in H,\ (v,w) \notin X(G)$.

        Luego H es no-dominante respecto a G.
    \end{proof}

    Usando los resultados de estos dos lemas podemos optimizar el algortimo cortando ramas en el árbol de recursión.
    \begin{enumerate}
        \item Por el primer Lema, cada vez que encontramos un conjunto dominante e independiente podemos ahí mismo devolver el que tenga menor cardinal entre ese conjunto y el mínimo encontrado hasta ese momento. Esto es así ya que sabemos que cualquier subconjunto del nuevo conjunto es no-dominante.
        \item Por el segundo Lema, al momento de sacar un nodo de un conjunto podemos chequear si el subconjunto es dominante o no. En caso de que no lo sea, ni siquiera lo procesamos, ya que no es dominante y ninguno de sus subconjuntos lo será.
    \end{enumerate}
\subsubsection{Pseudocódigo}
\begin{codesnippet}
funcion resolver:
    Creamos un vector de n elementos, llenandolo con los nodos desde 0 a n-1.
    llamamos a resolver_aux pasandole como parametro la matriz de adyacencia, el vector
        recién creado y la cantidad de nodos en el grafo.

funcion resolver_aux:
    Llamemos dom al conjunto dominante pasado por parametro.
    Llamemos cidm al conjunto dominante e independiente con menor cardinal encontrado
        hasta ahora.
    Si el cidm tiene tamaño 1 hacer
        Devuelvo cidm
    Sino hacer
        // Chequeamos si dom es independiente:
        Para i desde 0 hasta |dom| hacer:
            Para j desde i+1 hasta |dom| hacer:
                Si matriz_adyacencia[dom[i]][dom[j]] == TRUE hacer
                    dom NO es independiente
        Si es independiente hacer
            Devolvemos el conjunto con menor cardinal entre cidm y dom.
    Para i desde 0 hasta |dom| hacer
        Crear un vector nuevo llamado copia con los mismos nodos que dom.
        Borrar el nodo en la posicion i del vector copia.
        // Chequeamos si el conjunto copia es dominante:
        Para i desde 0 hasta n hacer:
            Si i no pertenece a copia hacer
                Bool nodo_valido = FALSE
                Para j desde 0 hasta |copia| hacer:
                    Si copia[j] == i hacer
                        nodo_valido = TRUE
                    Si matriz_adyacencia[i][copia[j]] == TRUE hacer
                        nodo_valido = TRUE
                Si nodo_valido == FALSE hacer
                    copia NO es dominante
        Si copia es dominante hacer
            Hacer un llamado recursivo a resolver_aux, pasando como parametro la matriz
                de adyacencia, cidm, copia y la cantidad de nodos en el grafo.
            Llamemos nuevo_cidm al conjunto que devuelve el llamado recursivo.
            Devolvemos el conjunto con menor cardinal entre cidm y nuevo_cidm.
\end{codesnippet}

\subsection{Ejercicio B}

\textit{Calcular el orden de complejidad temporal de peor caso del algoritmo.}
\medskip

Veamos las distintas partes del algoritmo.

En la función \textit{resolver} tenemos un ciclo de $\Theta(n)$ más un llamado al constructor de la estructura vector para construir el primer conjunto dominante que se realiza solo una vez. Este constructor tiene costo $\Theta(n)$\footnote{Referencia: \url{http://www.cplusplus.com/reference/vector/vector/vector/}}, y dentro del ciclo solo tenemos operaciones constantes (asignación), por lo que el costo, sin contar el llamado a la función \textit{resolver_aux}, es de $\Theta(n)$.
En la función \textit{resolver_aux} tenemos 5 ciclos distintos, 2 anidados entre sí y otros 3 anidados entre sí.

Los primeros 2 corresponden al chequeo de indepedencia. Dentro de ellos solo hay operaciones de costo constante (una asignacion y dos comparaciones) y se repiten cada uno $|dom|$ veces, donde $dom$ es el conjunto dominante actual. Luego, el chequeo de independencia toma: $\mathcal{O}(|dom|*|dom|)$, que en el peor caso es $\mathcal{O}(n^2)$.

De los otros 3 ciclos anidados, el primero corresponde a la iteración sobre el conjunto $dom$ mientras vamos probando quitar distintos nodos, y los otros 2 corresponden al chequeo de dominancia de los nuevos conjuntos generados.
El primer ciclo se ejecuta $|dom|$ veces, mientras que el segundo y el tercero $n$ y $|copia|$ veces respectivamente, donde $copia$ es el nuevo conjunto generado (como se muestra en el pseudocódigo). Además dentro del primer ciclo utilizamos la función \textit{erase} de vectores que permite borrar un elemento dado su índice y el constructor de la estructura vector por copia. Ambas operaciones tiene costo en el peor caso lineal en la cantidad de elementos del vector original \footnote{Referencias: \url{http://www.cplusplus.com/reference/vector/vector/erase/} y \url{http://www.cplusplus.com/reference/vector/vector/vector/}}. El resto de las operaciones en los 3 ciclos es de costo constante (comparaciones y asignaciones).

Luego, la complejidad de los 3 ciclos nos queda: $\mathcal{O}(|dom|*(|dom| + |copia| + |n|* (|copia|)))$, que asintoticamente equivale a $\mathcal{O}(n^3)$

Fuera de los ciclos en la función \textit{resolver_aux} solo tenemos operaciones constantes (comparaciones y asignaciones, más la función \textit{size} de vectores, que tiene costo constante\footnote{Referencia: \url{http://www.cplusplus.com/reference/vector/vector/size/}}). Entonces, el costo de ejecutar una vez la función \textit{resolver_aux}, sin tener en cuenta el llamado recursivo a si misma, es de $\mathcal{O}(n^3)$.

Ahora, como vimos en el pseudocódigo, la función \textit{resolver_aux} parte del conjunto $dom$ y hace en el peor caso $|dom|$ llamados recursivos a si misma, cada uno quitando un nodo posible de $|dom|$.

Luego, el peor caso posible es que revisemos todas las posibles combinaciones de nodos. Es decir, pasar por \textit{resolver_aux} la cantidad de veces del cardinal del Conjunto de Partes de V(G). O sea, en el peor caso \textit{resolver_aux} toma: $\mathcal{O}(2^n*n^3)$.

Entonces, la complejidad final del algoritmo es:
$$\mathcal{O}(2^n*n^3)$$
\subsection{Ejercicio C}

\textit{Realizar una experimentación que permita observar los tiempos de ejecución del algoritmo en función de los parámetros de la entrada y de las podas y/o estrategias implementadas.}
\medskip
