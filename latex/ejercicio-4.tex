\textit{Diseñar e implementar una heurística de búsqueda local para CIDM.}

\subsection{Ejercicio A}

\textit{Explicar detalladamente el algoritmo implementado. Plantear al menos dos vecindades distintas para la búsqueda y al menos dos soluciones iniciales.}

\medskip

\subsubsection{Algoritmo implementado}

Sea G=(V,E) un grafo simple, la heurística de búsqueda local propuesta genera una solución inicial valida, es decir un V' $\subseteq$ V que es dominante e independiente (CID), de dos formas:
\begin{enumerate}
	\item \textbf{Heurística constructiva golosa}: procedimiento descripto en el ejercicio anterior.
    \item \textbf{Procedimiento BFS modificado}: detallado a continuación.

\end{enumerate}

\subsubsection{Procedimiento BFS modificado:}

Partimos de incluir un vértice inicial $v$ a $V'$ y luego vamos a ir agregando vértices a $V'$ determinando si el vértice analizado debe incluirse en $V'$.
El BFS modificado funciona de la siguiente manera:
\medskip

\begin{codesnippet}
Los vértices están numerados de 0 a n-1.

Creamos un vector, llamado solucionInicial, de tamaño n para guardar el estado de los
vértices (si fue VISITADO o no)

Creamos un vector de tamaño n en donde para cada posición guardamos si
pertenece al CID (INCLUIDO o no)

Al vértice inicial v lo ponemos como VISITADO y INCLUIDO y lo incluimos en la cola.

Luego mientras no este vacía la cola:
    Sacamos el primer elemento de la cola (w) y lo ponemos INCLUIDO.
    Revisamos cada adyacente a w:
        Si algún adyacente esta INCLUIDO entonces hacemos w = NO INCLUIDO.
        Si el adyacente no fue VISITADO entonces lo ponemos como VISITADO y
        lo agregamos a la cola.

Repetimos el procedimiento para el resto de las componentes conexas, empezando por
el vértice de menor numeración de la componente analizada.
\end{codesnippet}

A continuación mostramos un ejemplo del recorrido BFS, en donde el vértice 0 ya fue visitado y se esta analizando sus adyacentes, en particular el vértice 1, el cual es provisoriamiente INCLUIDO:
\medskip

\tikz[every node/.style={draw,circle}] {
\node[fill=blue!40, text=white] (1) at (0, 0)  { 0 };
\node[fill=red!40, text=white] (2) at (2, 0)  { 1 };
\node (5) at (4, 0)  { 3 };
\node (6) at (6, 0)  { 4 };
\node (7) at (3,-1)  { 2 };
\draw (1) edge node[above,draw=none] {} (2);
\draw (5) edge node[above,draw=none] {} (6);
\draw (2) edge node[above,draw=none] {} (7);
}

Para luego ser desmarcado debido a la presencia de un adyacente INCLUIDO, siendo la solución generada la siguiente:
\medskip

\tikz[every node/.style={draw,circle}] {
\node[fill=blue!40, text=white] (1) at (0, 0)  { 0 };
\node (2) at (2, 0)  { 1 };
\node[fill=blue!40, text=white] (5) at (4, 0)  { 3 };
\node (6) at (6, 0)  { 4 };
\node[fill=blue!40, text=white] (7) at (3,-1)  { 2 };
\draw (1) edge node[above,draw=none] {} (2);
\draw (5) edge node[above,draw=none] {} (6);
\draw (2) edge node[above,draw=none] {} (7);
}



\subsubsection{Primer Criterio de Vecindad}

El primer criterio de vecindad implementado consiste en generar soluciones vecinas a partir de quitar k vértices que pertenecen al subconjunto CID de la solución inicial y agregar 1 vértice al subconjunto, donde k $\in \mathbb{N}$ y k $\geq$ 2. Logrando de esta manera una reducción en el cardinal del subconjunto CID de, al menos, un vértice.

Para llevar adelante exitosamente este intercambio, debemos buscar aquellos vértices no incluidos en CID en la solución inicial, que tengan, al menos, dos vértices adyacentes incluidos en CID, para poder incluir ese vértice en la solución vecina y quitar sus adyacentes.

\begin{itemize}
	\item Ejemplo de un cambio 4 por 1:

    \tikz[every node/.style={draw,circle}] {
		\node[fill=blue!40, text=white] (1) at (0, 0)  { 0 };
		\node (2) at (1, -1)  { 1 };
		\node[fill=blue!40, text=white] (5) at (2, -2)  { 3 };
		\node[fill=blue!40, text=white] (7) at (2, 0)  { 2 };
		\node[fill=blue!40, text=white] (8) at (0, -2)  { 4 };
		\node (9) at (5, 0)  { 0 };
		\node[fill=blue!40, text=white] (10) at (6, -1)  { 1 };
		\node (11) at (7, -2)  { 3 };
		\node (12) at (7, 0)  { 2 };
		\node (13) at (5, -2)  { 4 };
		\draw (1) edge node[above,draw=none] {} (2);
		\draw (5) edge node[above,draw=none] {} (2);
		\draw (2) edge node[above,draw=none] {} (7);
		\draw (2) edge node[above,draw=none] {} (8);
		\draw (9) edge node[above,draw=none] {} (10);
		\draw (11) edge node[above,draw=none] {} (10);
		\draw (10) edge node[above,draw=none] {} (12);
		\draw (10) edge node[above,draw=none] {} (13);
}

\end{itemize}

Sin embargo, para lograr una solución valida, los vértices quitados no pueden tener otros vértices adyacentes no incluidos en el subconjunto que, a su vez, no sean adyacentes al vértice agregado  y no sean dominados por otro vértice.

\begin{itemize}
	\item Ejemplo de solución invalida:

    \tikz[every node/.style={draw,circle}] {
		\node[fill=blue!40, text=white] (1) at (0, 0)  { 0 };
		\node (2) at (1, -1)  { 1 };
		\node[fill=blue!40, text=white] (5) at (2, -2)  { 3 };
		\node[fill=blue!40, text=white] (7) at (2, 0)  { 2 };
		\node[fill=blue!40, text=white] (8) at (0, -2)  { 4 };
		\node (14) at (3.5, 0)  { 5 };
		\node (9) at (5, 0)  { 0 };
		\node[fill=blue!40, text=white] (10) at (6, -1)  { 1 };
		\node (11) at (7, -2)  { 3 };
		\node (12) at (7, 0)  { 2 };
		\node (13) at (5, -2)  { 4 };
		\node (15) at (8.5, 0)  { 5 };
		\draw (1) edge node[above,draw=none] {} (2);
		\draw (5) edge node[above,draw=none] {} (2);
		\draw (2) edge node[above,draw=none] {} (7);
		\draw (2) edge node[above,draw=none] {} (8);
		\draw (7) edge node[above,draw=none] {} (14);
		\draw (9) edge node[above,draw=none] {} (10);
		\draw (11) edge node[above,draw=none] {} (10);
		\draw (10) edge node[above,draw=none] {} (12);
		\draw (10) edge node[above,draw=none] {} (13);
		\draw (12) edge node[above,draw=none] {} (15);
}

\end{itemize}

El procedimiento de búsqueda de los posibles soluciones vecinas funciona de la siguiente manera:
\medskip

\begin{codesnippet}
Para todo vértice, u, en el Grafo:
  Creamos un vector de tamaño n, llamado solucionAuxiliar, al cual le copiamos
  el contenido de la solucionInicial.
  Si solucionInicial[u] = NO INCLUIDO y |adyacentes a u| > 1 entonces:
     solucionAuxiliar[u] = INCLUIDO
     cantAdyacentesIncluidos = 0
     Para todo adyacente, v, de u:
         Si solucionInicial[v] = INCLUIDO entonces:
             cantAdyacentesIncluidos ++
             solucionAuxiliar[v] = NO INCLUIDO

  Si cantAdyacentesIncluidos > 1 entonces:
     Si esSolucion?(solucionAuxiliar) entonces:
       Buscar Nuevos Vecinos a partir de la solucionAuxiliar
       Interrumpir el ciclo
\end{codesnippet}

En el procedimiento descripto anteriormente falta detallar el comportamiento de la funciona auxiliar \textit{esSolucion?}, la cual sera descripta en el apartado siguiente, ya que es utilizado por ambos criterios.

\subsubsection{Segundo Criterio de Vecindad}
El segundo criterio de vecindad implementado consiste en generar soluciones vecinas a partir de quitar k vértices que pertenecen al subconjunto CID de la solución inicial y agregar, hasta, k-1 vértices al subconjunto, donde k $\in \mathbb{N}$ y k $\geq$ 2. Logrando de esta manera, una reducción en el cardinal del subconjunto CID de, al menos, un vértice.
El caso donde k = 2 no difiere del criterio aplicado en la primer vecindad, ya que k - 1 = 1. Sin embargo a partir de k $\geq$ 3 se observa un comportamiento distinto, ya que podemos agregar k-2 vértices para arreglar la solución, además del candidato original.

En este caso, para los casos no contemplados en el criterio anterior, debemos buscar vértices no incluidos en CID en la solución inicial, que tengan, al menos k vértices adyacentes incluidos en CID, donde k $\geq$ 3, y que a su vez tengan hasta k-2 vértices que son adyacentes a los adyacentes del vértice buscado que no están incluidos y no son dominados por otro vértice.

\begin{itemize}
	\item Ejemplo de un caso 4-2, el cual fallaba en el criterio anterior:

    \tikz[every node/.style={draw,circle}] {
		\node[fill=blue!40, text=white] (1) at (0, 0)  { 0 };
		\node (2) at (1, -1)  { 1 };
		\node[fill=blue!40, text=white] (5) at (2, -2)  { 3 };
		\node[fill=blue!40, text=white] (7) at (2, 0)  { 2 };
		\node[fill=blue!40, text=white] (8) at (0, -2)  { 4 };
		\node (14) at (3.5, 0)  { 5 };
		\node (9) at (5, 0)  { 0 };
		\node[fill=blue!40, text=white] (10) at (6, -1)  { 1 };
		\node (11) at (7, -2)  { 3 };
		\node (12) at (7, 0)  { 2 };
		\node (13) at (5, -2)  { 4 };
		\node[fill=blue!40, text=white] (15) at (8.5, 0)  { 5 };
		\draw (1) edge node[above,draw=none] {} (2);
		\draw (5) edge node[above,draw=none] {} (2);
		\draw (2) edge node[above,draw=none] {} (7);
		\draw (2) edge node[above,draw=none] {} (8);
		\draw (7) edge node[above,draw=none] {} (14);
		\draw (9) edge node[above,draw=none] {} (10);
		\draw (11) edge node[above,draw=none] {} (10);
		\draw (10) edge node[above,draw=none] {} (12);
		\draw (10) edge node[above,draw=none] {} (13);
		\draw (12) edge node[above,draw=none] {} (15);
}

\end{itemize}

\begin{itemize}
	\item Caso donde falla el segundo criterio:

    \tikz[every node/.style={draw,circle}] {
		\node (1)[fill=blue!40, text=white] at (0, 0)  { 0 };
		\node (2) at (1, -1)  { 1 };
		\node (3)[fill=blue!40, text=white] at (2, 0)  { 2 };
		\node (4)[fill=blue!40, text=white] at (2, -2)  { 3 };
		\node (5) at (3.5, 0)  { 4 };
		\node (6) at (3.5, -2)  { 5 };
		\node (7) at (5, 0)  { 0 };
		\node (8)[fill=blue!40, text=white] at (6, -1)  { 1 };
		\node (9) at (7, 0)  { 2 };
		\node (10) at (7, -2)  { 3 };
		\node (11)[fill=blue!40, text=white] at (8.5, 0)  { 4 };
		\node (12) at (8.5, -2)  { 5 };
		\draw (1) edge node[above,draw=none] {} (2);
		\draw (2) edge node[above,draw=none] {} (3);
		\draw (2) edge node[above,draw=none] {} (4);
		\draw (3) edge node[above,draw=none] {} (5);
		\draw (4) edge node[above,draw=none] {} (6);
		\draw (7) edge node[above,draw=none] {} (8);
		\draw (8) edge node[above,draw=none] {} (9);
		\draw (8) edge node[above,draw=none] {} (10);
		\draw (9) edge node[above,draw=none] {} (11);
		\draw (10) edge node[above,draw=none] {} (12);
}

\end{itemize}

El procedimiento de búsqueda de los posibles soluciones vecinas funciona de la siguiente manera:
\medskip

\begin{codesnippet}
Para todo vértice, u, en el Grafo:
  Creamos un vector de tamaño n, llamado solucionAuxiliar, al cual le copiamos
  el contenido de la solucionInicial.
  Si solucionInicial[u] = NO INCLUIDO y |adyacentes a u| > 1 entonces:
     solucionAuxiliar[u] = INCLUIDO
     cantAdyacentesIncluidos = 0
     Para todo adyacente, v, de u:
         Si solucionInicial[v] = INCLUIDO entonces:
             cantAdyacentesIncluidos ++
             solucionAuxiliar[v] = NO INCLUIDO

  Si cantAdyacentesIncluidos > 1 entonces:
     cantCambiosPosibles = cantAdyacentesIncluidos - 2
     arreglarSolucion(solucionAuxiliar, cantCambiosPosibles)
     Si esSolucion?(solucionAuxiliar) entonces:
       Buscar Nuevos Vecinos a partir de la solucionAuxiliar
       Interrumpir el ciclo
\end{codesnippet}

Falta detallar los procedimientos \textit{arreglarSolucion} y \textit{esSolucion?}, los cuales se pueden realizar en una sola función que llamaremos \textit{esSolucion?} cuyo comportamiento es el siguiente:
\begin{itemize}
	\item La función recibe como parámetros un vector con la solución a analizar y un entero con la cantidad de cambios posibles a realizar
	\item Miramos cada vértice del grafo, los cuales o están INCLUIDOS o NO INCLUIDOS en el subconjunto CID.
    \item Si el vértice esta INCLUIDO, sus adyacentes NO pueden estar INCLUIDOS. En caso de encontrar algún adyacente INCLUIDO, sabemos que el subconjunto analizado no es solución valida.
    \item Si el vértice NO esta INCLUIDO, entonces, al menos, 1 vértice adyacente tiene que estar INCLUIDO. En caso de no encontrar algún vértice adyacente INCLUIDO, tenemos dos casos:
    \begin{enumerate}
    	\item La variable entera que representa la cantidad de cambios posibles es 0. En este caso sabemos que el subconjunto analizado no es solución valida.
        \item La variable entera que representa la cantidad de cambios posibles es mayor a 0. En este caso el vértice pasa a estar INCLUIDO en el subconjunto, manteniéndose la validez de la solución, ya que el vértice NO tiene adyacentes INCLUIDOS. También reducimos la cantidad de cambios posibles en una unidad.
    \end{enumerate}

    \item En pseudocódigo:

\end{itemize}

\begin{codesnippet}
Como entrada tenemos el vector solucionAuxiliar con la solución a analizar y el entero
cantCambiosPosibles, que tiene la cantidad de vértices que podemos incluir.

Creamos una variable booleana, esSolucion inicializada en true.

Luego, para todo vértice, u, en el Grafo:
  Si solucionAuxiliar[u] = INCLUIDO y |adyacentes a u| > 0 entonces:
     Para todo adyacente, v, de u:
         Si solucionInicial[v] = INCLUIDO entonces:
             esSolucion = false
             Interrumpir el ciclo

  Sino Si |adyacentes a u| > 0, entonces:
       adyacenteIncluido = false
       Para todo adyacente, v, a u:
          Si solucionInicial[v] = INCLUIDO entonces:
             adyacenteIncluido = true
       Si not(adyacenteIncluido) y cantCambiosPosibles = 0 entonces:
         esSolucion = false
         Interrumpir el ciclo
       Sino Si not(adyacenteIncluido) entonces:
         solucionAuxiliar[u] = INCLUIDO
         cantCambiosPosibles --

  Sino entonces:
       esSolucion = (solucionAuxiliar[u] = INCLUIDO)
\end{codesnippet}

Es necesario aclarar que para el primer criterio de vecindad, la cantidad de cambios posibles es 0.

\subsection{Ejercicio B}

\textit{Calcular el orden de complejidad temporal de peor caso de una iteración del algoritmo.}
\medskip

La estructura de datos que utilizamos para representar los grafos son vectores con listas, donde cada posición del vector representa un vértice y las listas contienen los adyacentes a ese vértice.

A partir de los procedimientos expuestos en el punto anterior, pasamos a analizar la complejidad de la heurística propuesta, para solo una iteración:

\begin{enumerate}
  \item \textbf{Solución Inicial}
    \begin{itemize}
    	\item \underline{Heurística Golosa}: $\mathcal{O}(n*log(n) + m)$. Justificada anteriormente.
        \item \underline{BFS modificado}: Las cambios implementados en el BFS no alteran su complejidad original, siendo la misma $\mathcal{O}(n + m)$. \footnote{Referencia \url{https://en.wikipedia.org/wiki/Breadth-first_search}}
    \end{itemize}
  \item \textbf{Primer Criterio de Vecindad}

  Tenemos un ciclo que se repite $n$ veces, el cual tiene varias operaciones que se realizan internamente:
  \begin{itemize}
    \item Creación de un vector tamaño $n$ y copia de contenido: $\Theta{(n)}$
    \item Comparaciones y Asignaciones: $\mathcal{O}(1)$
    \item Ciclo de los adyacentes, cuya complejidad, sumada a la del ciclo principal, es $\mathcal{O}(n + m)$.
    \item Complejidad de la función esSolucion?: $\mathcal{O}(n + m)$. Detallada en el punto 4.
  \end{itemize}
  Por lo tanto la complejidad total de este procedimiento es: $\mathcal{O}(n*(n + n + m) + n + m)$, lo cual es: $\mathcal{O}(n*(n + m))$

  \item \textbf{Segundo Criterio de Vecindad}

    Misma situación que el punto anterior, tenemos un ciclo que se repite $n$ veces, el cual tiene varias operaciones que se realizan internamente:
  \begin{itemize}
    \item Creación de un vector tamaño $n$ y copia de contenido: $\Theta{(n)}$
    \item Comparaciones y Asignaciones: $\mathcal{O}(1)$
    \item Ciclo de los adyacentes, cuya complejidad, sumada a la del ciclo principal, es $\mathcal{O}(n + m)$.
    \item Complejidad de la función esSolucion?: $\mathcal{O}(n + m)$. Detallada en el punto 4.
  \end{itemize}
  Por lo tanto la complejidad total de este procedimiento es: $\mathcal{O}(n*(n + n + m) + n + m)$, lo cual es: $\mathcal{O}(n*(n + m))$

  \item \textbf{Procedimiento esSolucion?}

    Tenemos un ciclo que se repite $n$ veces, el cual tiene varias operaciones que se realizan internamente:
  \begin{itemize}
    \item Comparaciones y Asignaciones: $\mathcal{O}(1)$
    \item Ciclo de los adyacentes, cuya complejidad, sumada a la del ciclo principal, es $\mathcal{O}(n + m)$.
  \end{itemize}
  Por lo tanto la complejidad total de este procedimiento es: $\mathcal{O}(n + m)$.

\end{enumerate}

Podemos concluir que la complejidad temporal de la heurística es independiente del procedimiento utilizado para armar la solución inicial, y que utilizando el primer o segundo criterio de vecindad la complejidad es la misma: $\mathcal{O}(n*(n + m))$.\\

\medskip

\textbf{Cota superior para la cantidad de iteraciones:}
\medskip

Sabemos que cada iteración de las vecindades reduce, como mínimo, en 1 el cardinal del subconjunto CID. Por lo tanto, si partimos de una solución inicial en donde el cardinal del subconjunto es asintoticamente igual a la cantidad de vértices del Grafo, es posible que iteraremos hasta n-1 veces, hasta alcanzar una solución de 1 vértice. Es evidente que este es un caso extremo, de difícil realización, sin embargo brinda una cota superior a la cantidad de iteraciones.

\subsection{Ejercicio C}

\textit{Realizar una experimentación que permita observar la perfomance del algoritmo comparando los tiempos de ejecución y la calidad de las soluciones obtenidas.}

\medskip

Para llevar adelante las comparaciones, generamos instancias aleatorias con las siguientes características:
\begin{enumerate}
	\item Tomamos 10 muestras por cada valor de la cantidad de nodos $n$, desde 5 hasta 30, promediando sus valores.
    \item Para cada valor de $n$, generamos instancias para cada valor posible de $m$ , es decir valores que van desde 0 hasta $\frac{n*(n-1)}{2}$, asegurándonos la validez de los aristas generadas, es decir que no haya ejes repetidos ni loops.
\end{enumerate}

Contamos con 4 variantes posibles, que combinan dos modos de generar la solución inicial (BFS y Golosa) y dos criterios de vecindad:

\begin{itemize}
	\item \textbf{Tipo B1}: Utilizamos el BFS modificado para la solución inicial, y el primer criterio de vecindad.
    \item \textbf{Tipo G1}: Utilizamos la heurística golosa para la solución inicial, y el primer criterio de vecindad.
    \item \textbf{Tipo B2}: Utilizamos el BFS modificado para la solución inicial, y el segundo criterio de vecindad.
    \item \textbf{Tipo G2}: Utilizamos la heurística golosa para la solución inicia;, y el segundo criterio de vecindad.
\end{itemize}

Es importante destacar los siguientes puntos:

\begin{itemize}
	\item En el caso de las comparaciones de los tiempos de ejecución, el eje de las abscisas esta determinado por la cantidad de nodos del grafo y el eje de las ordenadas representará el tiempo que tardo el algoritmo en nanosegundos.
	\item En el caso de las comparaciones de las soluciones obtenidas, el eje de las abscisas esta determinado por la cantidad de nodos del grafo y el eje de las ordenadas representará el tamaño de la solución obtenida.
	\item La toma de tiempos en nanosegundos se realizó usando la librería 'chrono' de C++.
	\item La aleatorización de los ejes en sus extremos particulares se realizó con la función std::rand.
\end{itemize}

\subsubsection{Tiempos de ejecución}
Primero comparamos las maneras de obtener la solución inicial, para luego comparar las vecindades entre si. Por último comparamos las 4 combinaciones entre si.
\begin{itemize}
\item \textbf{Comparación BFS contra Goloso}
\end{itemize}
\begin{center}

    \begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={Tiempos de ejecución (nanoseconds)},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=1]{datos/ej4/tiemposn.txt};
    \addplot[color=red] table[x index=0,y index=3]{datos/ej4/tiemposn.txt};
    \legend{B1, G1}
    \end{axis}
    \end{tikzpicture}
		\begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=2]{datos/ej4/tiemposn.txt};
    \addplot[color=red] table[x index=0,y index=4]{datos/ej4/tiemposn.txt};
    \legend{B2, G2}
    \end{axis}
    \end{tikzpicture}
\end{center}
Los gráficos ponen en evidencia la paridad en términos de ejecución temporal de ambas variantes. Si bien existe una mínima diferencia en favor del Goloso, no es suficiente para concluir que esta es la mejor en términos de ejecución temporal.
\begin{itemize}
\item \textbf{Comparación Primer Criterio de Vecindad contra Segundo Criterio de Vecindad}
\end{itemize}
\begin{center}

    \begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={Tiempos de ejecución (nanoseconds)},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=1]{datos/ej4/tiemposn.txt};
    \addplot[color=red] table[x index=0,y index=2]{datos/ej4/tiemposn.txt};
    \legend{B1, B2}
    \end{axis}
    \end{tikzpicture}
		\begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=3]{datos/ej4/tiemposn.txt};
    \addplot[color=red] table[x index=0,y index=4]{datos/ej4/tiemposn.txt};
    \legend{G1, G2}
    \end{axis}
    \end{tikzpicture}
\end{center}

En este caso la similitud es mas evidente, por lo cual no podemos concluir que una sea mejor que la otra.
\begin{itemize}
\item \textbf{Comparación B1-G1-B2-G2}
\end{itemize}
\begin{center}

		\begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={Tiempos de ejecución (nanoseconds)},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=1]{datos/ej4/tiemposn.txt};
    \addplot[color=red] table[x index=0,y index=3]{datos/ej4/tiemposn.txt};
		\addplot[color=green] table[x index=0,y index=2]{datos/ej4/tiemposn.txt};
		\addplot[color=blue] table[x index=0,y index=4]{datos/ej4/tiemposn.txt};
    \legend{B1, G1, B2, G2}
    \end{axis}
    \end{tikzpicture}
\end{center}

La ultima comparación pone en evidencia que la perfomance en términos de ejecución temporal no difiere para las distintas variantes, lo cual va en sintonía con el hecho que todas tienen la misma complejidad temporal teórica, mostrada en el punto anterior. Por lo tanto la elección de que combinación es mejor sera resuelto por la calidad de las soluciones obtenidas con cada una de ellas.
\subsubsection{Calidad de la solución}

Repetimos el mismo procedimiento usado en la comparación de tiempos de ejecución, sin dejar de mencionar el hecho de que al generar las instancias de la manera descripta anteriormente, nos encontramos con el hecho que el tamaño de las soluciones no son enteros, lo cual responde a que promediamos para cada $n$ el tamaño de la solución para todas los valores de $m$ posibles.

\begin{itemize}
\item \textbf{Comparación BFS contra Goloso}
\end{itemize}
\begin{center}

    \begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={Tamaño del conjunto solución},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=1]{datos/ej4/resultadosn.txt};
    \addplot[color=red] table[x index=0,y index=2]{datos/ej4/resultadosn.txt};
    \legend{B1, G1}
    \end{axis}
    \end{tikzpicture}
		\begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=3]{datos/ej4/resultadosn.txt};
    \addplot[color=red] table[x index=0,y index=4]{datos/ej4/resultadosn.txt};
    \legend{B2, G2}
    \end{axis}
    \end{tikzpicture}
\end{center}
En ambos casos, se aprecia una paridad entre ambos soluciones, sin embargo hay una leve tendencia hacia la heurística golosa como mejor procedimiento para construir la solución inicial.
\begin{itemize}
\item \textbf{Comparación Primer Criterio de Vecindad contra Segundo Criterio de Vecindad}
\end{itemize}
\begin{center}

    \begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={Tamaño del conjunto solución},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=1]{datos/ej4/resultadosn.txt};
    \addplot[color=red] table[x index=0,y index=3]{datos/ej4/resultadosn.txt};
    \legend{B1, B2}
    \end{axis}
    \end{tikzpicture}
		\begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=2]{datos/ej4/resultadosn.txt};
    \addplot[color=red] table[x index=0,y index=4]{datos/ej4/resultadosn.txt};
    \legend{G1, G2}
    \end{axis}
    \end{tikzpicture}
\end{center}

Estos resultados nos inclinan a pensar que el segundo criterio de vecindad es el mejor criterio, lo cual es coherente con el hecho que el segundo criterio de vecindad es capaz de arreglar soluciones que el primer criterio de vecindad da como invalidas. Es decir, podríamos argumentar que como el primer criterio de vecindad es un caso particular del segundo criterio de vecindad (cuando no incluimos ningún vértice al subconjunto, mas allá del candidato) debería ser siempre mejor al primero. Sin embargo, la experimentación muestra casos donde el primer criterio es mejor, y eso se da en instancias donde arreglar una solución invalida nos inhibe de seguir explorando la solución original en búsqueda de un mejor caso. Por ejemplo:

\begin{itemize}

	\item Grafo de n = 9 y m = 13

\tikz[every node/.style={draw,circle}] {
	\node (1) at (0, 0)  { 1 };
	\node (2) at (4.5, 0)  { 2 };
	\node (3) at (2, -2)  { 3 };
	\node (4) at (2, 2)  { 4 };
	\node (5) at (7.5, -1.5)  { 5 };
	\node (6) at (1, -1)  { 6 };
	\node (7) at (3, 0)  { 7 };
	\node (8) at (2.5, -1)  { 8 };
	\node (9) at (4, -1)  { 9 };
	\draw (1) edge node[above,draw=none] {} (6);
	\draw (3) edge node[above,draw=none] {} (5);
	\draw (4) edge node[above,draw=none] {} (6);
	\draw (6) edge node[above,draw=none] {} (7);
	\draw (6) edge node[above,draw=none] {} (3);
	\draw (5) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (5);
	\draw (9) edge node[above,draw=none] {} (2);
	\draw (7) edge node[above,draw=none] {} (2);
	\draw (8) edge node[above,draw=none] {} (3);
}



\item \textbf{Solución Golosa}: como el mayor grado, 3, es compartido por varios vértices, empezamos por el menor numero de etiqueta, que es el 5, y así sucesivamente.

\tikz[every node/.style={draw,circle}] {
	\node (1) at (0, 0)  { 1 };
	\node (2)[fill=blue!40, text=white] at (4.5, 0)  { 2 };
	\node (3) at (2, -2)  { 3 };
	\node (4) at (2, 2)  { 4 };
	\node (5)[fill=blue!40, text=white] at (7.5, -1.5)  { 5 };
	\node (6)[fill=blue!40, text=white] at (1, -1)  { 6 };
	\node (7) at (3, 0)  { 7 };
	\node (8)[fill=blue!40, text=white] at (2.5, -1)  { 8 };
	\node (9) at (4, -1)  { 9 };
	\draw (1) edge node[above,draw=none] {} (6);
	\draw (3) edge node[above,draw=none] {} (5);
	\draw (4) edge node[above,draw=none] {} (6);
	\draw (6) edge node[above,draw=none] {} (7);
	\draw (6) edge node[above,draw=none] {} (3);
	\draw (5) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (5);
	\draw (9) edge node[above,draw=none] {} (2);
	\draw (7) edge node[above,draw=none] {} (2);
	\draw (8) edge node[above,draw=none] {} (3);
}


\item \textbf{Solución aplicando el segundo criterio de vecindad a la solución golosa}: tenemos 4 candidatos que cumplen con el hecho de tener 2 o mas adyacentes incluidos: 3, 4, 7, 9.
\begin{enumerate}
	\item Vértice 3: incluimos el 3, quitamos el 5, 6 y 8, por lo tanto podemos incluir un vértice mas, que sera el 1. Sin embargo el 4 no es dominado por nadie, por lo cual no es una solución valida.
		\item Vértice 4: incluimos el 4, y quitamos el 5 y el 6. No podemos incluir ningún vértice mas, por lo tanto el 1 no es dominado por nadie, no es una solución valida.
		\item Vértice 7: incluimos el 7 y quitamos el 2, 6 y 8. Incluimos el 1, y nos queda una solución valida.
		\item Vértice 9: no es contemplado, ya que obtuvimos una solución mejor con el vértice 7. Solución que ya no es posible mejorar.
\end{enumerate}
\tikz[every node/.style={draw,circle}] {
	\node (1)[fill=blue!40, text=white] at (0, 0)  { 1 };
	\node (2) at (4.5, 0)  { 2 };
	\node (3) at (2, -2)  { 3 };
	\node (4) at (2, 2)  { 4 };
	\node (5)[fill=blue!40, text=white] at (7.5, -1.5)  { 5 };
	\node (6) at (1, -1)  { 6 };
	\node (7)[fill=blue!40, text=white] at (3, 0)  { 7 };
	\node (8) at (2.5, -1)  { 8 };
	\node (9) at (4, -1)  { 9 };
	\draw (1) edge node[above,draw=none] {} (6);
	\draw (3) edge node[above,draw=none] {} (5);
	\draw (4) edge node[above,draw=none] {} (6);
	\draw (6) edge node[above,draw=none] {} (7);
	\draw (6) edge node[above,draw=none] {} (3);
	\draw (5) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (5);
	\draw (9) edge node[above,draw=none] {} (2);
	\draw (7) edge node[above,draw=none] {} (2);
	\draw (8) edge node[above,draw=none] {} (3);
}


\item \textbf{Solución aplicando el primer criterio de vecindad a la solución golosa}: los candidatos son los mismos que en el segundo criterio, sin embargo al no poder incluir vértice mas allá del candidato, la solución probando con el vértice 7 es invalida, ya que el 1 no es dominado por nadie. Por lo tanto probamos con incluir el 9, y quitar el 2, 5 y 8. Al hacer esto nos queda una solución valida de menor cardinal que en la solución golosa original y que si hubiésemos utilizado el segundo criterio

\tikz[every node/.style={draw,circle}] {
	\node (1) at (0, 0)  { 1 };
	\node (2) at (4.5, 0)  { 2 };
	\node (3) at (2, -2)  { 3 };
	\node (4) at (2, 2)  { 4 };
	\node (5) at (7.5, -1.5)  { 5 };
	\node (6)[fill=blue!40, text=white] at (1, -1)  { 6 };
	\node (7) at (3, 0)  { 7 };
	\node (8) at (2.5, -1)  { 8 };
	\node (9)[fill=blue!40, text=white] at (4, -1)  { 9 };
	\draw (1) edge node[above,draw=none] {} (6);
	\draw (3) edge node[above,draw=none] {} (5);
	\draw (4) edge node[above,draw=none] {} (6);
	\draw (6) edge node[above,draw=none] {} (7);
	\draw (6) edge node[above,draw=none] {} (3);
	\draw (5) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (4);
	\draw (7) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (8);
	\draw (9) edge node[above,draw=none] {} (5);
	\draw (9) edge node[above,draw=none] {} (2);
	\draw (7) edge node[above,draw=none] {} (2);
	\draw (8) edge node[above,draw=none] {} (3);
}

\end{itemize}

Sin embargo estos tipos de instancias son muy particulares, por lo cual podemos afirmar que la \textbf{mejor combinación} para la \textbf{heurística de búsqueda local} planteada es aquella que toma como \textbf{solución inicial} la generada por la \textbf{heurística golosa} y luego es mejorada por el \textbf{segundo criterio de vecindad}.

\begin{itemize}
\item \textbf{Comparación B1-G1-B2-G2}
\end{itemize}
\begin{center}

		\begin{tikzpicture}
    \begin{axis}[
        title={},
        xlabel={Cantidad de nodos del grafo(n)},
        ylabel={Tamaño del conjunto solución},
        scaled x ticks=false,
        scaled y ticks=false,
        enlargelimits=0.05,
        width=0.5\textwidth,
        height=0.5\textwidth,
        legend pos=north west,
        xmin=5
    ]
    \addplot[color=black] table[x index=0,y index=1]{datos/ej4/resultadosn.txt};
    \addplot[color=red] table[x index=0,y index=2]{datos/ej4/resultadosn.txt};
		\addplot[color=green] table[x index=0,y index=3]{datos/ej4/resultadosn.txt};
		\addplot[color=blue] table[x index=0,y index=4]{datos/ej4/resultadosn.txt};
    \legend{B1, G1, B2, G2}
    \end{axis}
    \end{tikzpicture}
\end{center}
